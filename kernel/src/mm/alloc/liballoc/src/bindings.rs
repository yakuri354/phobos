/* automatically generated by rust-bindgen 0.59.1 */

pub const VERSION: &'static [u8; 4usize] = b"1.1\0";
pub const ALIGNMENT: u32 = 16;
pub const LIBALLOC_MAGIC: u32 = 3221340382;
pub const LIBALLOC_DEAD: u32 = 3735936685;
pub type size_t = ::cty::size_t;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::cty::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}

extern "C" {
    pub fn __kmalloc(arg1: size_t) -> *mut ::cty::c_void;
}
extern "C" {
    pub fn __krealloc(arg1: *mut ::cty::c_void, arg2: size_t) -> *mut ::cty::c_void;
}
extern "C" {
    pub fn __kcalloc(arg1: size_t, arg2: size_t) -> *mut ::cty::c_void;
}
extern "C" {
    pub fn __kfree(arg1: *mut ::cty::c_void);
}
#[doc = " A structure found at the top of all system allocated"]
#[doc = " memory blocks. It details the usage of the memory block."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct liballoc_major {
    #[doc = "< Linked list information."]
    pub prev: *mut liballoc_major,
    #[doc = "< Linked list information."]
    pub next: *mut liballoc_major,
    #[doc = "< The number of pages in the block."]
    pub pages: ::cty::c_uint,
    #[doc = "< The number of pages in the block."]
    pub size: ::cty::c_uint,
    #[doc = "< The number of bytes used in the block."]
    pub usage: ::cty::c_uint,
    #[doc = "< A pointer to the first allocated memory in the block."]
    pub first: *mut liballoc_minor,
}
#[test]
fn bindgen_test_layout_liballoc_major() {
    assert_eq!(
        ::core::mem::size_of::<liballoc_major>(),
        40usize,
        concat!("Size of: ", stringify!(liballoc_major))
    );
    assert_eq!(
        ::core::mem::align_of::<liballoc_major>(),
        8usize,
        concat!("Alignment of ", stringify!(liballoc_major))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<liballoc_major>())).prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(liballoc_major),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<liballoc_major>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(liballoc_major),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<liballoc_major>())).pages as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(liballoc_major),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<liballoc_major>())).size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(liballoc_major),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<liballoc_major>())).usage as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(liballoc_major),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<liballoc_major>())).first as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(liballoc_major),
            "::",
            stringify!(first)
        )
    );
}
#[doc = " This is a structure found at the beginning of all"]
#[doc = " sections in a major block which were allocated by a"]
#[doc = " malloc, calloc, realloc call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct liballoc_minor {
    #[doc = "< Linked list information."]
    pub prev: *mut liballoc_minor,
    #[doc = "< Linked list information."]
    pub next: *mut liballoc_minor,
    #[doc = "< The owning block. A pointer to the major structure."]
    pub block: *mut liballoc_major,
    #[doc = "< A magic number to idenfity correctness."]
    pub magic: ::cty::c_uint,
    #[doc = "< The size of the memory allocated. Could be 1 byte or more."]
    pub size: ::cty::c_uint,
    #[doc = "< The size of memory requested."]
    pub req_size: ::cty::c_uint,
}
#[test]
fn bindgen_test_layout_liballoc_minor() {
    assert_eq!(
        ::core::mem::size_of::<liballoc_minor>(),
        40usize,
        concat!("Size of: ", stringify!(liballoc_minor))
    );
    assert_eq!(
        ::core::mem::align_of::<liballoc_minor>(),
        8usize,
        concat!("Alignment of ", stringify!(liballoc_minor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<liballoc_minor>())).prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(liballoc_minor),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<liballoc_minor>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(liballoc_minor),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<liballoc_minor>())).block as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(liballoc_minor),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<liballoc_minor>())).magic as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(liballoc_minor),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<liballoc_minor>())).size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(liballoc_minor),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<liballoc_minor>())).req_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(liballoc_minor),
            "::",
            stringify!(req_size)
        )
    );
}
extern "C" {
    #[doc = "< The root memory block acquired from the system."]
    #[link_name = "\u{1}_ZL9l_memRoot"]
    pub static mut l_memRoot: *mut liballoc_major;
}
extern "C" {
    #[doc = "< The major with the most free memory."]
    #[link_name = "\u{1}_ZL9l_bestBet"]
    pub static mut l_bestBet: *mut liballoc_major;
}
#[doc = "< The size of an individual page. Set up in liballoc_init."]
pub const l_pageSize: ::cty::c_uint = 4096;
#[doc = "< The number of pages to request per chunk. Set up in liballoc_init."]
pub const l_pageCount: ::cty::c_uint = 16;
#[doc = "< Running total of allocated memory."]
pub const l_allocated: ::cty::c_ulonglong = 0;
#[doc = "< Running total of used memory."]
pub const l_inuse: ::cty::c_ulonglong = 0;
#[doc = "< Number of warnings encountered"]
pub const l_warningCount: ::cty::c_longlong = 0;
#[doc = "< Number of actual errors"]
pub const l_errorCount: ::cty::c_longlong = 0;
#[doc = "< Number of possible overruns"]
pub const l_possibleOverruns: ::cty::c_longlong = 0;
